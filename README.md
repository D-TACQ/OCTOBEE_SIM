# Introduction
This is a magnetic simulation that simulates a linear scan in 3 dimensions of 3D Hall Effect sensors through a magnetic field.

The various files generate the scan path, do a simulation to get B-field reading of all points on that path.
This uses a configurable sample rate and time per axis of scan, with the default configuration 10kSPS.
A full path scan with one sensor and default time per axis generates ~80M points to be solved by the simulation.
The default number of sensors simulated is 8, each offset by 5mm from the adjacent sensor along a single axis.

# Setup
To install the dependencies a `requirements.txt` file has been provided.
This is easiest install and run from a virtual environment.
Create a virtual environment and install the requirements with pip:

```
python -m venv env_octo-bee
source env_octo-bee/bin/activate
pip install -r requirements.txt
```

To exit the virtual environment simpy type `deactivate` in the shell prompt.

# Run full simulation
The definition of all simulation parameters is done inside `config.yml`.
An example has been provided to get started.
You can copy this `config.yml` to create your own simulations.
After copying you must edit `config.py` to point to your edited version.

To run a full simulation, from definition of simulation to output to disk of muxed data, run these files in order:

`python path_scan_bfield_computation.py`  
After this first run with a single sensor you can plot and check out your generated path with the `path_sim.py`

`python offset_path_scan.py`  
This will generate `.npy` files for 7 more sensors, with results saved to disk in numpy array format. 
The example configuration will use ~15GB of disk space.

`python write_muxed_data.py`  
Finally to generate a data file in ACQ400 format.
By default this will only munge the first ~200k points into the binary format to keep the file size small.
The format is defined below:

| BYTE | 00 | 02 | 04 | 06 | 08 | 10 | .. | 60 | 62 | 64 | 68 | 72 | 76  | 80  | 84  | 88  | 92  |
|------|----|----|----|----|----|----|----|----|----|----|----|----|-----|-----|-----|-----|-----|
| AI   |CH01|CH02|CH03|CH04|CH05|CH06| .. |CH31|CH32|AQB1|AQB2|AQB3|SPAD0|SPAD1|SPAD2|SPAD3|SPAD4|
| FUNC |S1X |S1Y |S1Z |S1T |S2X |S2Y | .. |S8Z |S8T |XPOS|YPOS|ZPOS| CNT |USEC |USR1 |USR2 |USR3 |

## Output

### File Layout

All data, intermediate and final, is stored in the `data/` directory e.g.
```
~/PROJECTS/octo-bee$ ls -l data
-rw-r--r-- 1 craig craig 2064720128 Jun 24 11:03 B-field_zoff_0.npy
-rw-r--r-- 1 craig craig 2064720128 Jun 24 11:04 B-field_zoff_10.npy
-rw-r--r-- 1 craig craig 2064720128 Jun 24 11:05 B-field_zoff_15.npy
-rw-r--r-- 1 craig craig 2064720128 Jun 24 11:05 B-field_zoff_20.npy
-rw-r--r-- 1 craig craig 2064720128 Jun 24 11:06 B-field_zoff_25.npy
-rw-r--r-- 1 craig craig 2064720128 Jun 24 11:06 B-field_zoff_30.npy
-rw-r--r-- 1 craig craig 2064720128 Jun 24 11:07 B-field_zoff_35.npy
-rw-r--r-- 1 craig craig 2064720128 Jun 24 11:04 B-field_zoff_5.npy
-rw-r--r-- 1 craig craig  678720000 Jun 24 11:09 binary_data.bin
-rw-r--r-- 1 craig craig 2064720128 Jun 24 11:02 recorded_scan_path.npy
```

The `B-field_zoff_` files are numpy arrays of the scan in order start to finish, where the final digits in the filename designate the sensor (by offset from origin in mm).

`binary_data.bin` is the final data product as would be generated from an ACQ400 system.

`recorded_scan_path.npy` is the generated ordered scan path from start to finish. This is the input to the magnetic simulation and is generated by the path simulation code.

### Reading binary data

To read in the binary data for further analysis, a data reader function is provided in `data_reader.py`.

To see this in action type:
`python -i data_reader.py`

You are now in an interactive prompt and can look at the data:
```
>>> data_no_position.dtype.names

>>> data_w_position.dtype.names

>>> data_w_position['YPOS']

>>> data_no_pos['S1Y']
```
Take a look at the main of `data_reader.py` to see how this is done.

This uses numpy structured arrays ((numpy.org/doc/1.26/user/basics.rec.html)[https://numpy.org/doc/1.26/user/basics.rec.html]) to define the binary format.
This is the same mechanism as is used to write the binary files.
The code used to generate the dtype string can be found in `data_writer.py` and outputs something like:

```
[('S1X', '<i2'), ('S1Y', '<i2'), ('S1Z', '<i2'), ('S1T', '<i2'), ... , ('S8X', '<i2'), ('S8Y', '<i2'), ('S8Z', '<i2'), ('S8T', '<i2'), ('XPOS', '<i4'), ('YPOS', '<i4'), ('ZPOS', '<i4'), ('CNT', '<i4'), ('USEC', '<i4'), ('USR1', '<i4'), ('USR2', '<i4'), ('USR3', '<i4')]
```

The files are read back in as numpy arrays that can be indexed by each named field (e.g. `mydata['USEC']`) and further plotted (with matplotlib, seaborn, plotly etc.) or analysed (with pandas, polars, scipy etc.).

### Low level data dumps
** Python users should use the python example [reading-binary-data](#reading-binary-data) **

At the lowest level, an example of the final binary output should look something like:

```
~/PROJECTS/octo-bee$ hexdump -e '32/2 "%04x," 8/4 "%08x," "\n"' <  data/binary_data.bin | head

3cc4,21a4,14f4,3cc4,3d62,22fd,149b,3d62,3ea9,2490,13af,3ea9,407b,2671,12c9,407b,42c7,27a4,11e4,42c7,4581,2890,1106,4581,4897,29ad,1027,4897,4c03,2b0a,0f09,4c03,00000000,00000000,00000000,00000000,00000000,00002222,00003333,00005555,
3cc4,21a4,14f4,3cc4,3d63,22fd,149b,3d63,3ea9,2490,13af,3ea9,407b,2671,12c9,407b,42c8,27a4,11e4,42c8,4582,2890,1106,4582,4898,29ad,1027,4898,4c04,2b0a,0f09,4c04,00000000,00000011,00000000,00000001,00000064,00002222,00003333,00005555,
3cc5,21a4,14f4,3cc5,3d63,22fe,149b,3d63,3eaa,2490,13af,3eaa,407c,2671,12c9,407c,42c8,27a4,11e4,42c8,4583,2890,1107,4583,4899,29ad,1027,4899,4c05,2b0a,0f09,4c05,00000000,00000023,00000000,00000002,000000c8,00002222,00003333,00005555,
3cc5,21a4,14f4,3cc5,3d64,22fe,149b,3d64,3eaa,2490,13af,3eaa,407c,2672,12c9,407c,42c9,27a4,11e5,42c9,4583,2890,1107,4583,4899,29ad,1027,4899,4c05,2b0a,0f09,4c05,00000000,00000034,00000000,00000003,0000012c,00002222,00003333,00005555,
```

Stripping individual columns (eg to fit the page, or show in decimal is easy, eg

e.g. Show first 8 AI channels in decimal
```
hexdump -e '32/2 "%5d," 8/4 "%08x," "\n"' <  data/binary_data.bin | cut -d, -f1-8 | head
15556, 8612, 5364,15556,15714, 8957, 5275,15714
15556, 8612, 5364,15556,15715, 8957, 5275,15715
15557, 8612, 5364,15557,15715, 8958, 5275,15715
15557, 8612, 5364,15557,15716, 8958, 5275,15716
15558, 8612, 5365,15558,15716, 8958, 5276,15716
```

e.g. show all 32 bit data (non AI) in hex
```
# XXXXXX,YYYYYYYY,ZZZZZZZZ,SC______,USEC____,USER2___,USER3___,USER4___

hexdump -e '32/2 "%5d," 8/4 "%08x," "\n"' <  data/binary_data.bin | cut -d, -f33-40 | head
00000000,00000000,00000000,00000000,00000000,00002222,00003333,00005555
00000000,00000011,00000000,00000001,00000064,00002222,00003333,00005555
00000000,00000023,00000000,00000002,000000c8,00002222,00003333,00005555
00000000,00000034,00000000,00000003,0000012c,00002222,00003333,00005555
00000000,00000046,00000000,00000004,00000190,00002222,00003333,00005555
00000000,00000058,00000000,00000005,000001f4,00002222,00003333,00005555
00000000,00000069,00000000,00000006,00000258,00002222,00003333,00005555
00000000,0000007b,00000000,00000007,000002bc,00002222,00003333,00005555
00000000,0000008d,00000000,00000008,00000320,00002222,00003333,00005555
00000000,0000009e,00000000,00000009,00000384,00002222,00003333,00005555

```
e.g. Show X,Y,Z position, Sample Count & usec in decimal
```
hexdump -e '32/2 "%5d," 8/4 "%10d," "\n"' <  data/binary_data.bin | cut -d, -f33-37 | head
         0,         0,         0,         0,         0
         0,        17,         0,         1,       100
         0,        35,         0,         2,       200
         0,        52,         0,         3,       300
         0,        70,         0,         4,       400
```




# Path visualization

`python path_sim.py`

To run the simulator of the 3D raster path scanner with a visualization of the object under test.

Result:
![Plot of simulattion](https://github.com/D-TACQ/OCTOBEE_SIM/releases/download/v1.0.0/OCTOBEE_SIM_PATH_PLOT.png)





